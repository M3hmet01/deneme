/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body - Coffee Machine with Safety Sensor
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "i2c-lcd.h"  // LCD Kütüphanesi
#include <stdio.h>    // sprintf için
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
// --- HC-SR04 PIN TANIMLAMALARI ---
#define TRIG_PIN GPIO_PIN_12
#define TRIG_PORT GPIOD
#define ECHO_PIN GPIO_PIN_13
#define ECHO_PORT GPIOD
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
I2C_HandleTypeDef hi2c1;
TIM_HandleTypeDef htim2;

/* USER CODE BEGIN PV */
// --- HC-SR04 Değişkenleri ---
uint32_t val1 = 0;
uint32_t val2 = 0;
volatile uint16_t mesafecm = 0;

// LCD için İsim Dizileri
char* CoffeeNames[] = {
    "Bos",
    "Turk Kahvesi",
    "Espresso",
    "Ristretto",
    "Lungo",
    "Americano",
    "Latte"
    "Caramel Latte",
    "Cappuccino",
    "Mocha"
};

char* LevelNames[] = {
    "AZ  ",
    "ORTA",
    "COK "
};
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
static void MX_TIM2_Init(void);
static void MX_I2C1_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

// --- DWT Mikrosaniye Gecikme Fonksiyonu ---
void delay_us(uint32_t us)
{
    uint32_t startTick = DWT->CYCCNT;
    uint32_t delayTicks = us * (SystemCoreClock/1000000);
    while (DWT->CYCCNT - startTick < delayTicks);
}

// --- HC-SR04 Mesafe Okuma Fonksiyonu ---
uint16_t HCSR04_Read_Raw(void)
{
    uint16_t dist = 0;

    // Trigger Pinini 10 us boyunca HIGH yap
    HAL_GPIO_WritePin(TRIG_PORT, TRIG_PIN, GPIO_PIN_SET);
    delay_us(10);
    HAL_GPIO_WritePin(TRIG_PORT, TRIG_PIN, GPIO_PIN_RESET);

    // Timeout ayarı
    int timeout = 10000;
    while (!(HAL_GPIO_ReadPin(ECHO_PORT, ECHO_PIN)) && timeout--);
    val1 = DWT->CYCCNT;

    timeout = 10000;
    while ((HAL_GPIO_ReadPin(ECHO_PORT, ECHO_PIN)) && timeout--);
    val2 = DWT->CYCCNT;

    if(val2 > val1){
        uint32_t ticks = val2 - val1;
        float microseconds = ticks / (SystemCoreClock/1000000.0f);
        dist = (uint16_t)(microseconds / 58.0f);
    }
    return dist;
}

// --- FİLTRELİ OKUMA FONKSİYONU ---
// 5 ölçüm alır, sıralar ve ortadakini (Medyan) döndürür.
// Sıçramaları (50cm hatasını) yok eder.
uint16_t HCSR04_Read(void)
{
    uint16_t readings[5];
    uint16_t temp;

    // 1. ADIM: 5 Adet Örnek Al
    for (int i = 0; i < 5; i++)
    {
        readings[i] = HCSR04_Read_Raw();
        // Sensörün yankısının sönmesi için iki ölçüm arası azıcık bekle
        HAL_Delay(5);
    }

    // 2. ADIM: Bubble Sort ile Küçükten Büyüğe Sırala
    for (int i = 0; i < 4; i++) // 5 eleman için 4 tur yeterli
    {
        for (int j = 0; j < 4 - i; j++)
        {
            if (readings[j] > readings[j + 1])
            {
                // Yer değiştir (Swap)
                temp = readings[j];
                readings[j] = readings[j + 1];
                readings[j + 1] = temp;
            }
        }
    }

    // 3. ADIM: Ortadaki (Medyan) Değeri Döndür
    // Dizimiz sıralandı: {4, 4, 4, 6, 50} -> Ortadaki [2] nolu indekstir.
    return readings[2];
}

uint8_t currentTemp;
uint32_t ledTimer       = 0;
uint8_t CoffyGramBit    = 0x00;
uint16_t WaterMilimBit  = 0x00;
uint16_t MilkMilimBit   = 0x00;

int Keyboard_Read(void)
{
    // -------- ROW 1 --------
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_RESET);
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0)) return 1;
    if (HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_11)) return 2;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_2)) return 3;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_3)) return 'A';

    // -------- ROW 2 --------
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_RESET);
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0)) return 4;
    if (HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_11)) return 5;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_2)) return 6;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_3)) return 'B';

    // -------- ROW 3 --------
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_3, GPIO_PIN_RESET);
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0)) return 7;
    if (HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_11)) return 8;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_2)) return 9;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_3)) return 'C';

    // -------- ROW 4 --------
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0)) return '*';
    if (HAL_GPIO_ReadPin(GPIOE, GPIO_PIN_11)) return 0;
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_2)) return '#';
    if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_3)) return 'D';

    return -1;   // tuş yok
}

#define TEASPOON_GRAM 5.0f

void    SetTemperature          (  uint8_t   Temp       ) ;
void    SetCoffy_Rate           (  uint8_t   rate       ) ;
void    SetSugar_Rate           (  uint8_t   rate       ) {};
void    SetWater_amount         (  uint16_t  amount     ) ;
void    SetMilk_amount          (  uint16_t  amount     ) ;
void    SetCoffy_brewing_time   (  uint16_t  time       ) {};
void    SetCoffy_foam_rate      (  uint8_t   foam       ) {};

uint16_t ReadTemperature        ();

typedef struct{
    uint8_t     Temperature;
    uint8_t     Coffee_gram;
    uint16_t    Water_ml;
    uint16_t    Milk_ml;
    uint16_t    Brew_time_sec;
}Coffy_Ingrediants;

typedef struct {
    uint8_t Sugar_gram;
    uint8_t Foam_rate;
} User_Settings_t;

void Coffy_Make( const  volatile Coffy_Ingrediants *Coffy , const  volatile User_Settings_t *user )
{
    SetTemperature          (  Coffy ->Temperature       );
    SetCoffy_Rate           (  Coffy ->Coffee_gram       );
    SetWater_amount         (  Coffy ->Water_ml          );
    SetMilk_amount          (  Coffy ->Milk_ml           );
    SetCoffy_brewing_time   (  Coffy ->Brew_time_sec     );
    SetSugar_Rate           (user ->Sugar_gram       );
    SetCoffy_foam_rate      (user->Foam_rate);
}

typedef enum{
    COFFY_NONE ,
    TURK_KAHVESI,
    ESPRESSO,
    RISTRETTO,
    LUNGO,
    AMERICANO,
    LATTE,
    CARAMEL_LATTE,
    CAPPUCCINO,
    MOCHA,
    COFFY_NUMBER
}CoffyType_t;

typedef enum
{
    LEVEL_AZ = 0,
    LEVEL_ORTA,
    LEVEL_COK
} Level_t;

Level_t Sugar_Level = LEVEL_ORTA;
Level_t Foam_Level  = LEVEL_ORTA;

CoffyType_t selectedCoffee = COFFY_NONE;
int key;

volatile Coffy_Ingrediants Coffies[COFFY_NUMBER ] =  {
         [TURK_KAHVESI] = { .Temperature = 93, .Coffee_gram = 5, .Water_ml = 65, .Milk_ml = 0, .Brew_time_sec = 150 },
         [ESPRESSO] = { .Temperature = 92, .Coffee_gram = 8, .Water_ml = 30, .Milk_ml = 0, .Brew_time_sec = 25 },
         [RISTRETTO] = { .Temperature = 92, .Coffee_gram = 8, .Water_ml = 20, .Milk_ml = 0, .Brew_time_sec = 18 },
         [LUNGO] = { .Temperature = 92, .Coffee_gram = 8, .Water_ml = 60, .Milk_ml = 0, .Brew_time_sec = 40 },
         [AMERICANO] = { .Temperature = 92, .Coffee_gram = 10, .Water_ml = 110, .Milk_ml = 0, .Brew_time_sec = 25 },
         [LATTE] = { .Temperature = 65, .Coffee_gram = 5, .Water_ml = 30, .Milk_ml = 170, .Brew_time_sec = 25 },
         [CARAMEL_LATTE] = { .Temperature = 65, .Coffee_gram = 5, .Water_ml = 30, .Milk_ml = 170, .Brew_time_sec = 25 },
         [CAPPUCCINO] = { .Temperature = 65, .Coffee_gram = 8, .Water_ml = 30, .Milk_ml = 110, .Brew_time_sec = 25 },
         [MOCHA] = { .Temperature = 65, .Coffee_gram = 8, .Water_ml = 30, .Milk_ml = 130, .Brew_time_sec = 25 }
};

volatile User_Settings_t UserSettings = {
    .Sugar_gram = 0,
    .Foam_rate  = 50
};

uint8_t CoffeeGram_To_Bit(uint8_t gram)
{
    if      (gram == 0)   return 0b00;
    else if (gram <= 3)   return 0b01;
    else if (gram <= 5)   return 0b10;
    else                  return 0b11;
}

void SetCoffy_Rate(uint8_t rate) {
    CoffyGramBit = CoffeeGram_To_Bit(rate);
    if (CoffyGramBit & 0x01) HAL_GPIO_WritePin(Coffy_Gram_LED1_GPIO_Port , Coffy_Gram_LED1_Pin, GPIO_PIN_SET);
    else HAL_GPIO_WritePin(Coffy_Gram_LED1_GPIO_Port , Coffy_Gram_LED1_Pin, GPIO_PIN_RESET);

    if (CoffyGramBit & 0x02) HAL_GPIO_WritePin(Coffy_Gram_LED2_GPIO_Port , Coffy_Gram_LED2_Pin, GPIO_PIN_SET);
    else HAL_GPIO_WritePin(Coffy_Gram_LED2_GPIO_Port , Coffy_Gram_LED2_Pin, GPIO_PIN_RESET);
}

uint8_t WaterMilim_To_Bit(uint16_t Water_Milim)
{
    if      (Water_Milim == 0 )   return 0b00;
    else if (Water_Milim <= 30)   return 0b01;
    else if (Water_Milim <= 70)   return 0b10;
    else                          return 0b11;
}

void SetWater_amount(uint16_t Water_Milim) {
    WaterMilimBit = WaterMilim_To_Bit( Water_Milim);
    if (WaterMilimBit & 0x01) HAL_GPIO_WritePin(Water_Amount_LED1_GPIO_Port ,Water_Amount_LED1_Pin , GPIO_PIN_SET);
    else HAL_GPIO_WritePin(Water_Amount_LED1_GPIO_Port ,Water_Amount_LED1_Pin , GPIO_PIN_RESET);

    if (WaterMilimBit & 0x02) HAL_GPIO_WritePin(Water_Amount_LED2_GPIO_Port ,Water_Amount_LED2_Pin, GPIO_PIN_SET);
    else HAL_GPIO_WritePin(Water_Amount_LED2_GPIO_Port ,Water_Amount_LED2_Pin, GPIO_PIN_RESET);
}

uint8_t MilkMilim_To_Bit(  uint16_t  Milk_Milim     )
{
    if      (Milk_Milim == 0 )   return 0b00;
    else if (Milk_Milim <= 30)   return 0b01;
    else if (Milk_Milim <= 70)   return 0b10;
    else                         return 0b11;
}

// DÜZELTİLMİŞ SÜT LED FONKSİYONU (GPIOE Sabitlendi)
void SetMilk_amount(uint16_t Milk_Milim) {
    MilkMilimBit = MilkMilim_To_Bit( Milk_Milim);

    if (MilkMilimBit & 0x01) HAL_GPIO_WritePin(GPIOE, Milk_Amount_LED1_Pin , GPIO_PIN_SET);
    else HAL_GPIO_WritePin(GPIOE, Milk_Amount_LED1_Pin , GPIO_PIN_RESET);

    if (MilkMilimBit & 0x02) HAL_GPIO_WritePin(GPIOE, Milk_Amount_LED2_Pin, GPIO_PIN_SET);
    else HAL_GPIO_WritePin(GPIOE, Milk_Amount_LED2_Pin, GPIO_PIN_RESET);
}

uint16_t ReadTemperature(void)
{
    uint32_t sum = 0;
    uint16_t adcValue;
    for (int i = 0; i < 8; i++)
    {
        HAL_ADC_Start(&hadc1);
        HAL_ADC_PollForConversion(&hadc1, 10);
        adcValue = HAL_ADC_GetValue(&hadc1);
        HAL_ADC_Stop(&hadc1);
        sum += adcValue;
        HAL_Delay(2);
    }
    adcValue = sum / 8;
    currentTemp = (adcValue * 105) / 4095;
    return currentTemp;
}

// ------ SICAKLIK VE GÜVENLİK FONKSİYONU (HC-SR04 BURADA) ------
void SetTemperature(uint8_t targetTemp){

    // 1. Önce mesafeyi ölç (Güvenlik)
    mesafecm = HCSR04_Read();

    // 2. Güvenlik Kontrolü: Mesafe 10cm'den azsa DUR!
    if (mesafecm > 0 && mesafecm < 10)
    {
        // Isıtıcıyı kapat (PWM = 0)
        __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 0);

        // Uyarı LED'ini yak/söndür
        HAL_GPIO_TogglePin(Temperature_Warning_LED2_GPIO_Port, Temperature_Warning_LED2_Pin);
        HAL_GPIO_WritePin(Temperature_Ready_LED1_GPIO_Port, Temperature_Ready_LED1_Pin, GPIO_PIN_RESET);

        // Fonksiyondan çık (Isıtma kodlarını atla)
        return;
    }

    // 3. Normal Isıtma Mantığı
    __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_1, currentTemp);

    if  (currentTemp > targetTemp + 5){
        if (HAL_GetTick() - ledTimer >= 500)
        {
            HAL_GPIO_TogglePin(Temperature_Warning_LED2_GPIO_Port, Temperature_Warning_LED2_Pin);
            HAL_GPIO_WritePin (Temperature_Ready_LED1_GPIO_Port   ,  Temperature_Ready_LED1_Pin, GPIO_PIN_RESET);
            ledTimer = HAL_GetTick();
        }
    }
    else if(currentTemp >= (targetTemp - 5)  && currentTemp <= (targetTemp + 5)  ){
                HAL_GPIO_WritePin (Temperature_Ready_LED1_GPIO_Port   ,  Temperature_Ready_LED1_Pin, GPIO_PIN_SET);
                HAL_GPIO_WritePin  (Temperature_Warning_LED2_GPIO_Port ,  Temperature_Warning_LED2_Pin, GPIO_PIN_RESET);
    }
    else if (currentTemp <= targetTemp ){
        HAL_GPIO_WritePin(Temperature_Ready_LED1_GPIO_Port, Temperature_Ready_LED1_Pin, GPIO_PIN_RESET );
    }
}

void Sugar_Adjust(int key)
{
    if (key == 'A' || key == 'B')
    {
        if (key == 'A' && Sugar_Level < LEVEL_COK) Sugar_Level++;
        else if (key == 'B' && Sugar_Level > LEVEL_AZ) Sugar_Level--;

        lcd_clear();
        lcd_put_cur(0, 0);
        lcd_send_string("Seker Ayari:");
        lcd_put_cur(1, 0);
        lcd_send_string(LevelNames[Sugar_Level]);
        HAL_Delay(200);
    }
}

void Foam_Adjust(int key)
{
    if (key == 'C' || key == 'D')
    {
        if (key == 'C' && Foam_Level < LEVEL_COK) Foam_Level++;
        else if (key == 'D' && Foam_Level > LEVEL_AZ) Foam_Level--;

        lcd_clear();
        lcd_put_cur(0, 0);
        lcd_send_string("Kopuk Ayari:");
        lcd_put_cur(1, 0);
        lcd_send_string(LevelNames[Foam_Level]);
        HAL_Delay(200);
    }
}

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_ADC1_Init();
  MX_TIM2_Init();
  MX_I2C1_Init();

  /* USER CODE BEGIN 2 */
  // DWT Sayacını Aktif Et (HC-SR04 için gerekli)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CYCCNT = 0;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;

  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);

  // LCD Başlangıç
  lcd_init();
  lcd_clear();
  lcd_put_cur(0, 2);
  lcd_send_string("KAHVE MAKINESI");
  lcd_put_cur(1, 2);
  lcd_send_string("Hosgeldiniz...");
  HAL_Delay(2000);

  lcd_clear();
  lcd_put_cur(0, 0);
  lcd_send_string("Kahve Seciniz");
  /* USER CODE END 2 */

  /* Infinite loop */
  while (1)
  {
    // 1. Sıcaklık Oku
    currentTemp = ReadTemperature();

    // 2. Isıtıcı Kontrolü (HC-SR04 Safety Stop burada çalışır)
    SetTemperature(Coffies[selectedCoffee].Temperature);

    // 3. Klavye Oku
    key = Keyboard_Read();

    // Ayar Tuşları
    if(key == 'A' || key == 'B') Sugar_Adjust(key);
    if(key == 'C' || key == 'D') Foam_Adjust(key);

    // 4. Kahve Seçimi ve Yapımı
    if (key >= 1 && key <= 9)
    {
        selectedCoffee = (CoffyType_t)key;

        // Adım 1: Hazırlanıyor
        lcd_clear();
        lcd_put_cur(0, 0);
        lcd_send_string(CoffeeNames[selectedCoffee]);
        lcd_put_cur(1, 0);
        lcd_send_string("Hazirlaniyor...");
        HAL_Delay(1500);

        // Adım 2: Kahve Yap (LED'ler yanar, süreler işler)
        Coffy_Make(&Coffies[selectedCoffee], &UserSettings);
        HAL_Delay(2000);

        // Adım 3: Bilgi (Şeker/Köpük)
        lcd_clear();
        lcd_put_cur(0, 0);
        lcd_send_string("Seker: ");
        lcd_send_string(LevelNames[Sugar_Level]);
        lcd_put_cur(1, 0);
        lcd_send_string("Kopuk: ");
        lcd_send_string(LevelNames[Foam_Level]);
        HAL_Delay(2500);

        // Adım 4: Bitti
        lcd_clear();
        lcd_put_cur(0, 0);
        lcd_send_string(CoffeeNames[selectedCoffee]);
        lcd_put_cur(1, 0);
        lcd_send_string("Hazir! Afiyetle");
        HAL_Delay(2000);

        // Başa Dön
        lcd_clear();
        lcd_put_cur(0, 0);
        lcd_send_string("Kahve Seciniz");
    }

    HAL_Delay(50);
  }
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 50;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV4;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
}

static void MX_ADC1_Init(void)
{
  ADC_ChannelConfTypeDef sConfig = {0};
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 1;
  hadc1.Init.DMAContinuousRequests = DISABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }
  sConfig.Channel = ADC_CHANNEL_1;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
}

static void MX_I2C1_Init(void)
{
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
}

static void MX_TIM2_Init(void)
{
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};
  htim2.Instance = TIM2;
  // PWM Frekansı ayarı (84MHz / 840 / 100 = 1kHz)
  htim2.Init.Prescaler = 839;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 100; // 0-100% Duty Cycle için
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  HAL_TIM_MspPostInit(&htim2);
}

static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE(); // D Portunu Aktif Et (HC-SR04 için)

  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
                          |Coffy_Gram_Flag_Pin|Coffy_Gram_LED1_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOA, Temperature_Flag_Pin|Temperature_Ready_LED1_Pin|Temperature_Warning_LED2_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOB, Coffy_Gram_LED2_Pin|Water_Amount_Flag_Pin|Water_Amount_LED1_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOE, Water_Amount_LED2_Pin|Milk_Amount_Flag_Pin|Milk_Amount_LED1_Pin|Milk_Amount_LED2_Pin, GPIO_PIN_RESET);

  // Trigger Pin Başlangıç Durumu Low
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);

  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
                          |Coffy_Gram_Flag_Pin|Coffy_Gram_LED1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  // KEYPAD GİRİŞLERİ (PULLDOWN YAPILDI)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = Temperature_Flag_Pin|Temperature_Ready_LED1_Pin|Temperature_Warning_LED2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = Coffy_Gram_LED2_Pin|Water_Amount_Flag_Pin|Water_Amount_LED1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = Water_Amount_LED2_Pin|Milk_Amount_Flag_Pin|Milk_Amount_LED1_Pin|Milk_Amount_LED2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  // KEYPAD GİRİŞİ (PULLDOWN YAPILDI)
  GPIO_InitStruct.Pin = GPIO_PIN_11;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  // HC-SR04 TRIG (PD12) -> OUTPUT
  GPIO_InitStruct.Pin = GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  // HC-SR04 ECHO (PD13) -> INPUT
  GPIO_InitStruct.Pin = GPIO_PIN_13;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
}

void Error_Handler(void)
{
  __disable_irq();
  while (1)
  {
  }
}
#ifdef USE_FULL_ASSERT
void assert_failed(uint8_t *file, uint32_t line)
{
}
#endif
